10. 가장 짧은 문자거리
설명

한 개의 문자열 s와 문자 t가 주어지면 문자열 s의 각 문자가 문자 t와 떨어진 최소거리를 출력하는 프로그램을 작성하세요.


입력
첫 번째 줄에 문자열 s와 문자 t가 주어진다. 문자열과 문자는 소문자로만 주어집니다.

문자열의 길이는 100을 넘지 않는다.


출력
첫 번째 줄에 각 문자열 s의 각 문자가 문자 t와 떨어진 거리를 순서대로 출력한다.


예시 입력 1 

teachermode e

예시 출력 1

1 0 1 2 1 0 1 2 2 1 0

# 내 문제 풀이
- 1시간 넘게...풀어봐도 해결 못함. 결국 바로 강좌를 봄
- 우선, 문자열과 문자를 입력 받는데, 나는 문자열속에 해당 문자만가 몇개 포함되었고
- 그 갯수만큼의 길이의 배열을 만드려고 했다.
- 왜냐하면 문자열이 그 배열만큼 반복하면서 (이중포문?) 최소값을 구하면 될 거라고 생각했기 때문에
- 하지만 의도와는 다르게 풀이가 잘 안된다...
---
# 선생님 문제 풀이
- teachermode 라는 문자열이 들어왔고, 문자는 e가 들어왔을 때
- 1. 제일 왼쪽의 e 부터 시작한다
- 임의의 숫자 P는 문자열보다 큰 아무 숫자나 놓는다 (편의상 1000, 문자열의 길이는 100을 넘지 않는다)
- teacher의 인덱스를 돌텐데 첫번째 문자 t 의 경우 왼쪽에 아무 문자가 없기에 1000에서 1을 더한 1001을 넣어준다
- te 에서 e 똑같은 문자를 만났을 때는 0을 넣어준다
- 그 다음부터는 1씩 증가시켜준다
- 따라서 teachermode 는 
- t(1001) e(0) a(1) c(2) h(3) e(0) r(1) m(2) o(3) d(4) e(0)
- 1001 0 1 2 3 0 1 2 3 4 0 이 된다

- 2. 제일 오른쪽의 e 부터 시작한다
- 위와 같은 과정을 반복하면
- t(1) e(0) a(3) c(2) h(1) e(0) r(4) m(3) o(2) d(1) e(0)
- 1 0 3 2 1 0 4 3 2 1 0 이 된다

- 3. 위에와 아래의 값을 비교해가면서 작은 값을 남겨놓으면 된다.
- 1001 0 1 2 3 0 1 2 3 4 0
- 1    0 3 2 1 0 4 3 2 1 0
- --> 1 0 1 2 1 0 1 2 2 1 0
--- 
```java
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String str = scanner.next();
        char c = scanner.next().charAt(0);
        for(int x : answer(str, c)){
            System.out.print(x+" ");
        }
    }

    public static int[] answer(String s, char t) {
        int[] answer = new int[s.length()]; // 들어온 문자의 길이의 배열 생성
        int p = 1000; // 임의의 숫자(문자의 길이보다 무조건 커야함)
        for (int i = 0; i < s.length(); i++) {
            // 문자의 왼쪽부터 접근, 같은 문자면 0 아니면 p = p+1을 한다
            if (s.charAt(i) == t) {
                p = 0;
                answer[i] = p;
            } else {
                p++;
                answer[i] = p;
            }
        }
        p = 1000; // p 다시 초기화
        for (int i = s.length() - 1; i >= 0; i--) {
            // 문자의 오른쪽부터 접근, 같은 문자면 0 아니면 p = p+1을 한다
            if (s.charAt(i) == t) {
                p = 0;
                // answer[i] = p; <- 어차피 0이 들어가 있어서 굳이 0을 또 넣을 필요는 없다.
            } else {
                p++;
                answer[i] = Math.min(answer[i], p);// 비교 후 작은값을 넣는다.
            }
        }

        return answer;
    }
}
```
---
- 어려웠던 문제다.
- 해설도 중요하지만, 코드와 함께 보기 위해선 
- 주석을 바로바로 달아야겠다.
- 앞으론 주석다는 습관을 들이자.